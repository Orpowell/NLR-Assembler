import csv
import logging
import pickle
import sys
from itertools import groupby


import click
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

logging.basicConfig(stream=sys.stdout, format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S',
                    level=logging.INFO)


def extract_mapping_data(sam_file, NLR_annotation):
    """
    The function takes a SAM file as an input and generates a dictionary of all the reads that have been mapped to a
    given refernce sequence in the SAM file as list.

    :param NLR_annotation:
    :param sam_file: reads mapped to contigs generated by assembly of reads
    :return: dictionary: {contig:[all mapped reads]}
    """
    contig_read_dictionary = {}
    logging.info("extracting infromation from SAM file...")
    with open(sam_file) as file:
        for line in file:
            # extract all reference sequence names from SAM file and add to dictionary with an empty list
            if line.startswith("@SQ"):
                seq_name = line.split("\t")[1][3:]
                contig_read_dictionary[seq_name] = []

            # skip the header added by samtools
            elif line.startswith("@PG"):
                continue

            # read line of SAM file and extract reference sequence and query sequence names then append query sequence
            # to a list in the dictionary using the reference sequence as a key
            else:
                read_info = line.split("\t")
                query_name = read_info[0]
                reference_name = read_info[2]
                # if a sequence is unmapped to a reference move onto the next read
                if reference_name == "*":
                    continue
                else:
                    contig_read_dictionary[reference_name].append(query_name)

    logging.info("extracting NLR annotaion data...")
    nlr_contigs = []
    with open(NLR_annotation) as annotations:
        for line in annotations:
            nlr_contigs.append(line.split("\t")[0])

    nlr_read_dictionary = {nlr: contig_read_dictionary[nlr] for nlr in nlr_contigs}

    return nlr_read_dictionary


def convert_reads_to_hexidecimal(contig_read_dictionary, index):
    """
    The function takes a dictionary of contigs each with a list of reads mapped to that contig and converts the read
    names to a list of rgb values based on an index file. The list RGB values is then converted to a string of
    hexidecimal values that can later be analysed to compare the similarity of contigs.

    :param contig_read_dictionary: dictionary of reads mapped to each contig generated by extracting_mapping_data()
    :param index: csv file where each read has been assigned a colour based its adapter sequence
    :return: contig_hex_dicitonary: {contig: string of hexidecimal values assinged for each read}
    """
    logging.info("extracting infromation from index file...")
    with open(index, mode='r') as inp:
        index_reader = csv.reader(inp)
        ID_colour_dict = {rows[0]: rows[1] for rows in index_reader}

    logging.info("converting Seq IDs to RGB values...")
    contig_rgb = {contig: tuple(map(lambda x: ID_colour_dict[x], contig_read_dictionary[contig])) for contig in
                  contig_read_dictionary}

    logging.info("converting rgb values to hexidecimal...")
    contig_hex_dictionary = {
        contig: list(map(lambda x: '#%02x%02x%02x' % tuple(map(int, x.split(","))), contig_rgb[contig])) for
        contig in contig_rgb}

    return contig_hex_dictionary


def calculate_cosine_similarity(contig_hex_dictionary):
    logging.info("converting hexidecimal to strings...")
    contig_adapter_profiles = [" ".join(contig_hex_dictionary[contig]) for contig in
                               contig_hex_dictionary]

    logging.info("calculating cosine similarity...")
    count_array = CountVectorizer()
    profile_count_array = count_array.fit_transform(contig_adapter_profiles)
    cosine_array = cosine_similarity(profile_count_array)

    return cosine_array


def group_contigs(contig_hex, cosine_array, threshold):
    def filter_by_cosine(array, dictionary):
        valid_contigs = []
        for n, cosine in enumerate(array):
            if cosine > threshold:
                valid_contigs.append(dictionary[n])

        return valid_contigs

    logging.info('grouping contigs...')

    normalised_keys = {n: k for n, k in enumerate(list(contig_hex.keys()))}

    array_dict = {normalised_keys[n]: array for n, array in enumerate(cosine_array)}

    matched_contig = [filter_by_cosine(v, normalised_keys) for k, v in array_dict.items()]

    non_duplicate_contig_groups = list(matched_contig for matched_contig, _ in groupby(matched_contig))

    logging.info('writing data to pickle...')
    with open(f'grouped_contigs_({threshold}).pkl', 'wb') as f:
        pickle.dump(non_duplicate_contig_groups, f)


def plot_cosine_similarity(cosine_array, threshold):
    logging.info("plotting cosine similarity matrix...")
    fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [1, 1.2]}, figsize=(100, 50))
    ax1.get_shared_y_axes().join(ax2)
    g1 = sns.heatmap(cosine_array, cbar=False, ax=ax1, vmin=0, vmax=100, linewidths=0.5, linecolor='black')
    g2 = sns.heatmap(cosine_array, ax=ax2, mask=cosine_array <= 75, vmin=0, vmax=100, linewidths=0.5,
                     linecolor='black')
    g2.set_yticks([])
    g2.set_facecolor("black")

    g1.set_yticklabels([])
    g1.set_xticklabels([])
    g2.set_xticklabels([])

    g1.set_title('Cosine Similarity')
    g2.set_title(f'Threshold: {threshold}')
    g2.figure.axes[-1].yaxis.label.set_size(1000)

    g2.collections[0].colorbar.ax.tick_params(labelsize=75)
    g2.set_title(f'Grouping @ {threshold}', fontsize=100)
    g1.set_title('Cosine Similarity', fontsize=100)

    fig.savefig(f"cosine_similarity_plots({threshold}).png", bbox_inches='tight')


@click.command()
@click.option('-i', '--samfile', type=str, required=True, help="SAM file")
@click.option('-n', '--nlr', type=str, required=True, help="NLR annotator file")
@click.option('-x', '--index', type=str, required=True, help="Index file generated with colour mapper")
@click.option('-p', "--plot", type=bool, required=False, default=False, help="plot cosine similarity matrix")
@click.option('-t', '--threshold', type=float, required=False, default=0.8, help="cosine similarity threshold for grouping/plotting")
def calculate_similarity(samfile, nlr, index, plot, threshold):
    nlr_contig_reads = extract_mapping_data(samfile, nlr)
    contig_hex = convert_reads_to_hexidecimal(nlr_contig_reads, index)
    cosine_matrix = calculate_cosine_similarity(contig_hex)
    group_contigs(contig_hex, cosine_matrix, threshold)

    if plot:
        plot_cosine_similarity(cosine_matrix, threshold)
